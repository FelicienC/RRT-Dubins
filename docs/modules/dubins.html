<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>dubins &mdash; RRT-Dubins 0.0.1 documentation</title>
    
    <link rel="stylesheet" type="text/css" href="../static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../static/css/spc-extend.css">
    <link rel="stylesheet" href="../static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <script type="text/javascript" src="../static/js/copybutton.js"></script>
    <link rel="index" title="Index" href="../genindex.html" >
    <link rel="search" title="Search" href="../search.html" >
    <link rel="top" title="RRT-Dubins 0.0.1 documentation" href="../index.html" >
    <link rel="up" title="Module code" href="index.html" > 
  </head>
  <body>

<div class="container">
  <div class="top-scipy-org-logo-header">
    <a href="../index.html">
      <img style="border: 0;" alt="Volocopter" src="../static/img/logo.png"></a>
    </div>
  </div>
</div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
        <li class="active"><a href="https://github.com/FelicienC/RRT-Dubins">Github</a></li>
        <li class="active"><a href="https://felicienc.github.io/RRT-Dubins/">Docs</a></li>
	
        <li class="active"><a href="../index.html">RRT-Dubins 0.0.1 documentation</a></li>
	
          <li class="active"><a href="index.html" accesskey="U">Module code</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="../py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <h1>Source code for dubins</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<div class="viewcode-block" id="ortho"><a class="viewcode-back" href="../Dubins.html#dubins.ortho">[docs]</a><span class="k">def</span> <span class="nf">ortho</span><span class="p">(</span><span class="n">vect2d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes an orthogonal vector to the one given&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="o">-</span><span class="n">vect2d</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">vect2d</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span></div>

<div class="viewcode-block" id="dist"><a class="viewcode-back" href="../Dubins.html#dubins.dist">[docs]</a><span class="k">def</span> <span class="nf">dist</span><span class="p">(</span><span class="n">pt_a</span><span class="p">,</span> <span class="n">pt_b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Euclidian distance between two (x, y) points&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">pt_a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">pt_b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">pt_a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">pt_b</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span></div>

<div class="viewcode-block" id="Dubins"><a class="viewcode-back" href="../Dubins.html#dubins.Dubins">[docs]</a><span class="k">class</span> <span class="nc">Dubins</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class implementing a Dubins path planner with a constant turn radius.</span>
<span class="sd">    </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    radius : float</span>
<span class="sd">        The radius of the turn used in all the potential trajectories.</span>
<span class="sd">    point_separation : float</span>
<span class="sd">        The distance between points of the trajectories. More points increases</span>
<span class="sd">        the precision of the path but also augments the computation time of the</span>
<span class="sd">        colision check.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    dubins_path</span>
<span class="sd">        Computes the shortest dubins path between two given points.</span>
<span class="sd">    generate_points_straight</span>
<span class="sd">        Turns a path into a set of point representing the trajectory, for</span>
<span class="sd">        dubins paths when the path is one of LSL, LSR, RSL, RSR.</span>
<span class="sd">    generate_points_curve</span>
<span class="sd">        Turns a path into a set of point representing the trajectory, for</span>
<span class="sd">        dubins paths when the path is one of RLR or LRL.</span>
<span class="sd">    find_center</span>
<span class="sd">        Compute the center of the circle described by a turn.</span>
<span class="sd">    lsl</span>
<span class="sd">        Dubins path with a left straight left trajectory.</span>
<span class="sd">    rsr</span>
<span class="sd">        Dubins path with a right straight right trajectory.</span>
<span class="sd">    rsl</span>
<span class="sd">        Dubins path with a right straight left trajectory.</span>
<span class="sd">    lsr</span>
<span class="sd">        Dubins path with a left straight right trajectory.</span>
<span class="sd">    lrl</span>
<span class="sd">        Dubins path with a left right left trajectory.</span>
<span class="sd">    rlr</span>
<span class="sd">        Dubins path with a right left right trajectory.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">point_separation</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">radius</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">point_separation</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">point_separation</span> <span class="o">=</span> <span class="n">point_separation</span>

<div class="viewcode-block" id="Dubins.all_options"><a class="viewcode-back" href="../Dubins.html#dubins.Dubins.all_options">[docs]</a>    <span class="k">def</span> <span class="nf">all_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes all the possible Dubin&#39;s path and returns them, in the form</span>
<span class="sd">        of a list of tuples representing each option: (path_length,</span>
<span class="sd">        dubins_path, straight).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start :  tuple</span>
<span class="sd">            In the form (x, y, psi), with psi in radians.</span>
<span class="sd">            The representation of the inital point.</span>
<span class="sd">        end : tuple</span>
<span class="sd">            In the form (x, y, psi), with psi in radians.</span>
<span class="sd">            The representation of the final point.</span>
<span class="sd">        sort : bool</span>
<span class="sd">            If the list of option has to be sorted by decreasing cost or not.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        The shortest list of points (x, y) linking the initial and final points</span>
<span class="sd">        given as input with only turns of a defined radius and straight line.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">center_0_left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_center</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">)</span>
        <span class="n">center_0_right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_center</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">)</span>
        <span class="n">center_2_left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_center</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">)</span>
        <span class="n">center_2_right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_center</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">)</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lsl</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">center_0_left</span><span class="p">,</span> <span class="n">center_2_left</span><span class="p">),</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">rsr</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">center_0_right</span><span class="p">,</span> <span class="n">center_2_right</span><span class="p">),</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">rsl</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">center_0_right</span><span class="p">,</span> <span class="n">center_2_left</span><span class="p">),</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">lsr</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">center_0_left</span><span class="p">,</span> <span class="n">center_2_right</span><span class="p">),</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">rlr</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">center_0_right</span><span class="p">,</span> <span class="n">center_2_right</span><span class="p">),</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">lrl</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">center_0_left</span><span class="p">,</span> <span class="n">center_2_left</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">options</span></div>

<div class="viewcode-block" id="Dubins.dubins_path"><a class="viewcode-back" href="../Dubins.html#dubins.Dubins.dubins_path">[docs]</a>    <span class="k">def</span> <span class="nf">dubins_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes all the possible Dubin&#39;s path and returns the sequence of</span>
<span class="sd">        points representing the shortest option.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start :  tuple</span>
<span class="sd">            In the form (x, y, psi), with psi in radians.</span>
<span class="sd">            The representation of the inital point.</span>
<span class="sd">        end : tuple</span>
<span class="sd">            In the form (x, y, psi), with psi in radians.</span>
<span class="sd">            The representation of the final point.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        The shortest list of points (x, y) linking the initial and final points</span>
<span class="sd">        given as input with only turns of a defined radius and straight line.</span>
<span class="sd">        In the form of a (2xn) numpy array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">options</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_options</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="n">dubins_path</span><span class="p">,</span> <span class="n">straight</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_points</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">dubins_path</span><span class="p">,</span> <span class="n">straight</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dubins.generate_points"><a class="viewcode-back" href="../Dubins.html#dubins.Dubins.generate_points">[docs]</a>    <span class="k">def</span> <span class="nf">generate_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">dubins_path</span><span class="p">,</span> <span class="n">straight</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transforms the dubins path in a succession of points in the 2D plane.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start: tuple</span>
<span class="sd">            In the form (x, y, psi), with psi in radians.</span>
<span class="sd">            The representation of the inital point.</span>
<span class="sd">        end: tuple</span>
<span class="sd">            In the form (x, y, psi), with psi in radians.</span>
<span class="sd">            The representation of the final point.</span>
<span class="sd">        dubins_path: tuple</span>
<span class="sd">            The representation of the dubins path in the form of a tuple</span>
<span class="sd">            containing:</span>
<span class="sd">                - the angle of the turn in the first circle, in rads.</span>
<span class="sd">                - the angle of the turn in the last circle, in rads.</span>
<span class="sd">                - the angle of the turn in the central circle, in rads, or the</span>
<span class="sd">                length of the central segment if straight is true.</span>
<span class="sd">        straight: bool</span>
<span class="sd">            True if their is a central segment in the dubins path.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        The shortest list of points (x, y) linking the initial and final points</span>
<span class="sd">        given as input with only turns of a defined radius and straight line.</span>
<span class="sd">        In the form of a (2xn) numpy array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">straight</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_points_straight</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">dubins_path</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_points_curve</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">dubins_path</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dubins.lsl"><a class="viewcode-back" href="../Dubins.html#dubins.Dubins.lsl">[docs]</a>    <span class="k">def</span> <span class="nf">lsl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">center_0</span><span class="p">,</span> <span class="n">center_2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Left-Straight-Left trajectories.</span>
<span class="sd">        First computes the poisition of the centers of the turns, and then uses</span>
<span class="sd">        the fact that the vector defined by the distance between the centers</span>
<span class="sd">        gives the direction and distance of the straight segment.</span>

<span class="sd">        .. image:: img/twoturnssame.svg</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : tuple</span>
<span class="sd">            (x, y, psi) coordinates of the inital point.</span>
<span class="sd">        end : tuple</span>
<span class="sd">            (x, y, psi) coordinates of the final point.</span>
<span class="sd">        center_0 : tuple</span>
<span class="sd">            (x, y) coordinates of the center of the first turn.</span>
<span class="sd">        center_2 : tuple</span>
<span class="sd">            (x, y) coordinates of the center of the last turn.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        total_len : float</span>
<span class="sd">            The total distance of this path.</span>
<span class="sd">        (beta_0, beta_2, straight_dist) : tuple</span>
<span class="sd">            The dubins path, i.e. the angle of the first turn, the angle of the</span>
<span class="sd">            last turn, and the length of the straight segment.</span>
<span class="sd">        straight : bool</span>
<span class="sd">            True, to indicate that this path contains a straight segment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">straight_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">center_0</span><span class="p">,</span> <span class="n">center_2</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">((</span><span class="n">center_2</span><span class="o">-</span><span class="n">center_0</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">center_2</span><span class="o">-</span><span class="n">center_0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">beta_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">end</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">beta_0</span> <span class="o">=</span> <span class="p">(</span><span class="n">alpha</span><span class="o">-</span><span class="n">start</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">%</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">total_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="o">*</span><span class="p">(</span><span class="n">beta_2</span><span class="o">+</span><span class="n">beta_0</span><span class="p">)</span><span class="o">+</span><span class="n">straight_dist</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">total_len</span><span class="p">,</span> <span class="p">(</span><span class="n">beta_0</span><span class="p">,</span> <span class="n">beta_2</span><span class="p">,</span> <span class="n">straight_dist</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dubins.rsr"><a class="viewcode-back" href="../Dubins.html#dubins.Dubins.rsr">[docs]</a>    <span class="k">def</span> <span class="nf">rsr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">center_0</span><span class="p">,</span> <span class="n">center_2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Right-Straight-Right trajectories.</span>
<span class="sd">        First computes the poisition of the centers of the turns, and then uses</span>
<span class="sd">        the fact that the vector defined by the distance between the centers</span>
<span class="sd">        gives the direction and distance of the straight segment.</span>
<span class="sd">        </span>
<span class="sd">        .. image:: img/twoturnssame.svg</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : tuple</span>
<span class="sd">            (x, y, psi) coordinates of the inital point.</span>
<span class="sd">        end : tuple</span>
<span class="sd">            (x, y, psi) coordinates of the final point.</span>
<span class="sd">        center_0 : tuple</span>
<span class="sd">            (x, y) coordinates of the center of the first turn.</span>
<span class="sd">        center_2 : tuple</span>
<span class="sd">            (x, y) coordinates of the center of the last turn.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        total_len : float</span>
<span class="sd">            The total distance of this path.</span>
<span class="sd">        (beta_0, beta_2, straight_dist) : tuple</span>
<span class="sd">            The dubins path, i.e. the angle of the first turn, the angle of the</span>
<span class="sd">            last turn, and the length of the straight segment.</span>
<span class="sd">        straight : bool</span>
<span class="sd">            True, to indicate that this path contains a straight segment.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">straight_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">center_0</span><span class="p">,</span> <span class="n">center_2</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">((</span><span class="n">center_2</span><span class="o">-</span><span class="n">center_0</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">center_2</span><span class="o">-</span><span class="n">center_0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">beta_2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">end</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">alpha</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">beta_0</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">alpha</span><span class="o">+</span><span class="n">start</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">%</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">total_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="o">*</span><span class="p">(</span><span class="n">beta_2</span><span class="o">+</span><span class="n">beta_0</span><span class="p">)</span><span class="o">+</span><span class="n">straight_dist</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">total_len</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">beta_0</span><span class="p">,</span> <span class="o">-</span><span class="n">beta_2</span><span class="p">,</span> <span class="n">straight_dist</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dubins.rsl"><a class="viewcode-back" href="../Dubins.html#dubins.Dubins.rsl">[docs]</a>    <span class="k">def</span> <span class="nf">rsl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">center_0</span><span class="p">,</span> <span class="n">center_2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Right-Straight-Left trajectories.</span>
<span class="sd">        Because of the change in turn direction, it is a little more complex to</span>
<span class="sd">        compute than in the RSR or LSL cases. First computes the position of</span>
<span class="sd">        the centers of the turns, and then uses the rectangle triangle defined</span>
<span class="sd">        by the point between the two circles, the center point of one circle</span>
<span class="sd">        and the tangeancy point of this circle to compute the straight segment</span>
<span class="sd">        distance.</span>

<span class="sd">        .. image:: img/twoturnsopposite.svg</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : tuple</span>
<span class="sd">            (x, y, psi) coordinates of the inital point.</span>
<span class="sd">        end : tuple</span>
<span class="sd">            (x, y, psi) coordinates of the final point.</span>
<span class="sd">        center_0 : tuple</span>
<span class="sd">            (x, y) coordinates of the center of the first turn.</span>
<span class="sd">        center_2 : tuple</span>
<span class="sd">            (x, y) coordinates of the center of the last turn.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        total_len : float</span>
<span class="sd">            The total distance of this path.</span>
<span class="sd">        (beta_0, beta_2, straight_dist) : tuple</span>
<span class="sd">            The dubins path, i.e. the angle of the first turn, the angle of the</span>
<span class="sd">            last turn, and the length of the straight segment.</span>
<span class="sd">        straight : bool</span>
<span class="sd">            True, to indicate that this path contains a straight segment.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">median_point</span> <span class="o">=</span> <span class="p">(</span><span class="n">center_2</span> <span class="o">-</span> <span class="n">center_0</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">psia</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">median_point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">median_point</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">half_intercenter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">median_point</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">half_intercenter</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="o">/</span><span class="n">half_intercenter</span><span class="p">)</span>
        <span class="n">beta_0</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">psia</span><span class="o">+</span><span class="n">alpha</span><span class="o">-</span><span class="n">start</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">beta_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">+</span><span class="n">end</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="n">alpha</span><span class="o">-</span><span class="n">psia</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">straight_dist</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">half_intercenter</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">total_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="o">*</span><span class="p">(</span><span class="n">beta_2</span><span class="o">+</span><span class="n">beta_0</span><span class="p">)</span><span class="o">+</span><span class="n">straight_dist</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">total_len</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">beta_0</span><span class="p">,</span> <span class="n">beta_2</span><span class="p">,</span> <span class="n">straight_dist</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dubins.lsr"><a class="viewcode-back" href="../Dubins.html#dubins.Dubins.lsr">[docs]</a>    <span class="k">def</span> <span class="nf">lsr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">center_0</span><span class="p">,</span> <span class="n">center_2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Left-Straight-Right trajectories.</span>
<span class="sd">        Because of the change in turn direction, it is a little more complex to</span>
<span class="sd">        compute than in the RSR or LSL cases. First computes the poisition of</span>
<span class="sd">        the centers of the turns, and then uses the rectangle triangle defined</span>
<span class="sd">        by the point between the two circles, the center point of one circle</span>
<span class="sd">        and the tangeancy point of this circle to compute the straight segment</span>
<span class="sd">        distance.</span>

<span class="sd">        .. image:: img/twoturnsopposite.svg</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : tuple</span>
<span class="sd">            (x, y, psi) coordinates of the inital point.</span>
<span class="sd">        end : tuple</span>
<span class="sd">            (x, y, psi) coordinates of the final point.</span>
<span class="sd">        center_0 : tuple</span>
<span class="sd">            (x, y) coordinates of the center of the first turn.</span>
<span class="sd">        center_2 : tuple</span>
<span class="sd">            (x, y) coordinates of the center of the last turn.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        total_len : float</span>
<span class="sd">            The total distance of this path.</span>
<span class="sd">        (beta_0, beta_2, straight_dist) : tuple</span>
<span class="sd">            The dubins path, i.e. the angle of the first turn, the angle of the</span>
<span class="sd">            last turn, and the length of the straight segment.</span>
<span class="sd">        straight : bool</span>
<span class="sd">            True, to indicate that this path contains a straight segment.</span>

<span class="sd">            &quot;&quot;&quot;</span>
        <span class="n">median_point</span> <span class="o">=</span> <span class="p">(</span><span class="n">center_2</span> <span class="o">-</span> <span class="n">center_0</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">psia</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">median_point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">median_point</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">half_intercenter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">median_point</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">half_intercenter</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="o">/</span><span class="n">half_intercenter</span><span class="p">)</span>
        <span class="n">beta_0</span> <span class="o">=</span> <span class="p">(</span><span class="n">psia</span><span class="o">-</span><span class="n">alpha</span><span class="o">-</span><span class="n">start</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">beta_2</span> <span class="o">=</span> <span class="p">(</span><span class="o">.</span><span class="mi">5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">-</span><span class="n">end</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">alpha</span><span class="o">+</span><span class="n">psia</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">straight_dist</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">half_intercenter</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">total_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="o">*</span><span class="p">(</span><span class="n">beta_2</span><span class="o">+</span><span class="n">beta_0</span><span class="p">)</span><span class="o">+</span><span class="n">straight_dist</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">total_len</span><span class="p">,</span> <span class="p">(</span><span class="n">beta_0</span><span class="p">,</span> <span class="o">-</span><span class="n">beta_2</span><span class="p">,</span> <span class="n">straight_dist</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dubins.lrl"><a class="viewcode-back" href="../Dubins.html#dubins.Dubins.lrl">[docs]</a>    <span class="k">def</span> <span class="nf">lrl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">center_0</span><span class="p">,</span> <span class="n">center_2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Left-right-Left trajectories.</span>
<span class="sd">        Using the isocele triangle made by the centers of the three circles,</span>
<span class="sd">        computes the required angles.</span>

<span class="sd">        .. image:: img/threeturns.svg</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : tuple</span>
<span class="sd">            (x, y, psi) coordinates of the inital point.</span>
<span class="sd">        end : tuple</span>
<span class="sd">            (x, y, psi) coordinates of the final point.</span>
<span class="sd">        center_0 : tuple</span>
<span class="sd">            (x, y) coordinates of the center of the first turn.</span>
<span class="sd">        center_2 : tuple</span>
<span class="sd">            (x, y) coordinates of the center of the last turn.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        total_len : float</span>
<span class="sd">            The total distance of this path.</span>
<span class="sd">        (beta_0, beta_2, straight_dist) : tuple</span>
<span class="sd">            The dubins path, i.e. the angle of the first turn, the angle of the</span>
<span class="sd">            last turn, and the length of the straight segment.</span>
<span class="sd">        straight : bool</span>
<span class="sd">            False, to indicate that this path does not contain a straight part.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dist_intercenter</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">center_0</span><span class="p">,</span> <span class="n">center_2</span><span class="p">)</span>
        <span class="n">intercenter</span> <span class="o">=</span> <span class="p">(</span><span class="n">center_2</span> <span class="o">-</span> <span class="n">center_0</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">psia</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">intercenter</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">intercenter</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">&lt;</span> <span class="n">dist_intercenter</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">dist_intercenter</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">))</span>
        <span class="n">beta_0</span> <span class="o">=</span> <span class="p">(</span><span class="n">psia</span><span class="o">-</span><span class="n">start</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">-</span><span class="n">gamma</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">beta_1</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">psia</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="n">end</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">-</span><span class="n">gamma</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">total_len</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">-</span><span class="n">gamma</span><span class="o">+</span><span class="nb">abs</span><span class="p">(</span><span class="n">beta_0</span><span class="p">)</span><span class="o">+</span><span class="nb">abs</span><span class="p">(</span><span class="n">beta_1</span><span class="p">))</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">total_len</span><span class="p">,</span>
                <span class="p">(</span><span class="n">beta_0</span><span class="p">,</span> <span class="n">beta_1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">-</span><span class="n">gamma</span><span class="p">),</span>
                <span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dubins.rlr"><a class="viewcode-back" href="../Dubins.html#dubins.Dubins.rlr">[docs]</a>    <span class="k">def</span> <span class="nf">rlr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">center_0</span><span class="p">,</span> <span class="n">center_2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Right-left-right trajectories.</span>
<span class="sd">        Using the isocele triangle made by the centers of the three circles,</span>
<span class="sd">        computes the required angles.</span>

<span class="sd">        .. image:: img/threeturns.svg</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : tuple</span>
<span class="sd">            (x, y, psi) coordinates of the inital point.</span>
<span class="sd">        end : tuple</span>
<span class="sd">            (x, y, psi) coordinates of the final point.</span>
<span class="sd">        center_0 : tuple</span>
<span class="sd">            (x, y) coordinates of the center of the first turn.</span>
<span class="sd">        center_2 : tuple</span>
<span class="sd">            (x, y) coordinates of the center of the last turn.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        total_len : float</span>
<span class="sd">            The total distance of this path.</span>
<span class="sd">        (beta_0, beta_2, straight_dist) : tuple</span>
<span class="sd">            The dubins path, i.e. the angle of the first turn, the angle of the</span>
<span class="sd">            last turn, and the length of the straight segment.</span>
<span class="sd">        straight : bool</span>
<span class="sd">            False, to indicate that this path does not contain a straight part.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dist_intercenter</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">center_0</span><span class="p">,</span> <span class="n">center_2</span><span class="p">)</span>
        <span class="n">intercenter</span> <span class="o">=</span> <span class="p">(</span><span class="n">center_2</span> <span class="o">-</span> <span class="n">center_0</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">psia</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">intercenter</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">intercenter</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">&lt;</span> <span class="n">dist_intercenter</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">dist_intercenter</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">))</span>
        <span class="n">beta_0</span> <span class="o">=</span> <span class="o">-</span><span class="p">((</span><span class="o">-</span><span class="n">psia</span><span class="o">+</span><span class="p">(</span><span class="n">start</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">-</span><span class="n">gamma</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
        <span class="n">beta_1</span> <span class="o">=</span> <span class="o">-</span><span class="p">((</span><span class="n">psia</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="n">end</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">-</span><span class="n">gamma</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
        <span class="n">total_len</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">-</span><span class="n">gamma</span><span class="o">+</span><span class="nb">abs</span><span class="p">(</span><span class="n">beta_0</span><span class="p">)</span><span class="o">+</span><span class="nb">abs</span><span class="p">(</span><span class="n">beta_1</span><span class="p">))</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">total_len</span><span class="p">,</span>
                <span class="p">(</span><span class="n">beta_0</span><span class="p">,</span> <span class="n">beta_1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">-</span><span class="n">gamma</span><span class="p">),</span>
                <span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dubins.find_center"><a class="viewcode-back" href="../Dubins.html#dubins.Dubins.find_center">[docs]</a>    <span class="k">def</span> <span class="nf">find_center</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">side</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given an initial position, and the direction of the turn, computes the</span>
<span class="sd">        center of the circle with turn radius self.radius passing by the intial</span>
<span class="sd">        point.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        point : tuple</span>
<span class="sd">            In the form (x, y, psi), with psi in radians.</span>
<span class="sd">            The representation of the inital point.</span>
<span class="sd">        side : Char</span>
<span class="sd">            Either &#39;L&#39; to indicate a left turn, or &#39;R&#39; for a right turn.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        coordinates : 2x1 Array Like</span>
<span class="sd">            Coordinates of the center of the circle describing the turn.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">side</span> <span class="ow">in</span> <span class="s1">&#39;LR&#39;</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">point</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span> <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="s1">&#39;L&#39;</span> <span class="k">else</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">,</span>
                         <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">))</span></div>

<div class="viewcode-block" id="Dubins.generate_points_straight"><a class="viewcode-back" href="../Dubins.html#dubins.Dubins.generate_points_straight">[docs]</a>    <span class="k">def</span> <span class="nf">generate_points_straight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For the 4 first classes of dubins paths, containing in the middle a</span>
<span class="sd">        straight section.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : tuple</span>
<span class="sd">            Start position in the form (x, y, psi).</span>
<span class="sd">        end : tuple</span>
<span class="sd">            End position in the form (x, y, psi).</span>
<span class="sd">        path : tuple</span>
<span class="sd">            The computed dubins path, a tuple containing:</span>
<span class="sd">                - the angle of the turn in the first circle, in rads</span>
<span class="sd">                - the angle of the turn in the last circle, in rads</span>
<span class="sd">                - the length of the straight line in between</span>
<span class="sd">            A negative angle means a right turn (antitrigonometric), and a</span>
<span class="sd">            positive angle represents a left turn.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        The shortest list of points (x, y) linking the initial and final points</span>
<span class="sd">        given as input with only turns of a defined radius and straight line.</span>
<span class="sd">        In the form of a (2xn) numpy array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">total</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="o">*</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="nb">abs</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">+</span><span class="n">path</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># Path length</span>
        <span class="n">center_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_center</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span> <span class="k">if</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;R&#39;</span><span class="p">)</span>
        <span class="n">center_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_center</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span> <span class="k">if</span> <span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;R&#39;</span><span class="p">)</span>

        <span class="c1"># We first need to find the points where the straight segment starts</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="n">start</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">ini</span> <span class="o">=</span> <span class="n">center_0</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)])</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">ini</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">start</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
        <span class="c1"># We then identify its end</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="n">end</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">fin</span> <span class="o">=</span> <span class="n">center_2</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)])</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">fin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">end</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">dist_straight</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">ini</span><span class="p">,</span> <span class="n">fin</span><span class="p">)</span>

        <span class="c1"># We can now generate all the points with the desired precision</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_separation</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">:</span> <span class="c1"># First turn</span>
                <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">circle_arc</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">center_0</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">total</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">:</span> <span class="c1"># Last turn</span>
                <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">circle_arc</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">center_2</span><span class="p">,</span> <span class="n">x</span><span class="o">-</span><span class="n">total</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># Straight segment</span>
                <span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span><span class="o">/</span><span class="n">dist_straight</span>
                <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="o">*</span><span class="n">fin</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">coeff</span><span class="p">)</span><span class="o">*</span><span class="n">ini</span><span class="p">)</span>
        <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">end</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dubins.generate_points_curve"><a class="viewcode-back" href="../Dubins.html#dubins.Dubins.generate_points_curve">[docs]</a>    <span class="k">def</span> <span class="nf">generate_points_curve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For the two last paths, where the trajectory is a succession of 3</span>
<span class="sd">        turns. First computing the position of the center of the central turn,</span>
<span class="sd">        then using the three circles to apply the angles given in the path</span>
<span class="sd">        argument.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start : tuple</span>
<span class="sd">            Start position in the form (x, y, psi).</span>
<span class="sd">        end : tuple</span>
<span class="sd">            End position in the form (x, y, psi).</span>
<span class="sd">        path : tuple</span>
<span class="sd">            The computed dubins path, a tuple containing:</span>
<span class="sd">                - the angle of the turn in the first circle, in rads</span>
<span class="sd">                - the angle of the turn in the last circle, in rads</span>
<span class="sd">                - the angle of the turn in the central circle, in rads</span>
<span class="sd">            A negative angle means a right turn (antitrigonometric), and a</span>
<span class="sd">            positive angle represents a left turn.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        The shortest list of points (x, y) linking the initial and final points</span>
<span class="sd">        given as input with only turns of a defined radius. In the form of a</span>
<span class="sd">        (2xn) numpy array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">total</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="o">*</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="nb">abs</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="nb">abs</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="n">center_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_center</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span> <span class="k">if</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;R&#39;</span><span class="p">)</span>
        <span class="n">center_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_center</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span> <span class="k">if</span> <span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;R&#39;</span><span class="p">)</span>
        <span class="n">intercenter</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">center_0</span><span class="p">,</span> <span class="n">center_2</span><span class="p">)</span>
        <span class="n">center_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">center_0</span> <span class="o">+</span> <span class="n">center_2</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span>\
                   <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">ortho</span><span class="p">((</span><span class="n">center_2</span><span class="o">-</span><span class="n">center_0</span><span class="p">)</span><span class="o">/</span><span class="n">intercenter</span><span class="p">)</span>\
                    <span class="o">*</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">intercenter</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">psi_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">((</span><span class="n">center_1</span> <span class="o">-</span> <span class="n">center_0</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span>
                           <span class="p">(</span><span class="n">center_1</span> <span class="o">-</span> <span class="n">center_0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>

        <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_separation</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">:</span> <span class="c1"># First turn</span>
                <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">circle_arc</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">center_0</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">total</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">:</span> <span class="c1"># Last turn</span>
                <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">circle_arc</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">center_2</span><span class="p">,</span> <span class="n">x</span><span class="o">-</span><span class="n">total</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># Middle Turn</span>
                <span class="n">angle</span> <span class="o">=</span> <span class="n">psi_0</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">vect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)])</span>
                <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">center_1</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="o">*</span><span class="n">vect</span><span class="p">)</span>
        <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">end</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dubins.circle_arc"><a class="viewcode-back" href="../Dubins.html#dubins.Dubins.circle_arc">[docs]</a>    <span class="k">def</span> <span class="nf">circle_arc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the point located on the circle of center center and radius</span>
<span class="sd">        defined by the class, at the angle x.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reference : float</span>
<span class="sd">            Angular starting point, in radians.</span>
<span class="sd">        beta : float</span>
<span class="sd">            Used actually only to know the direction of the rotation, and hence</span>
<span class="sd">            to know if the path needs to be added or substracted from the</span>
<span class="sd">            reference angle.</span>
<span class="sd">        center : tuple</span>
<span class="sd">            (x, y) coordinates of the center of the circle from which we need a</span>
<span class="sd">            point on the circumference.</span>
<span class="sd">        x : float</span>
<span class="sd">            The lenght of the path on the circle.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        The coordinates of the point on the circle, in the form of a tuple.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">reference</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="p">((</span><span class="n">x</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
        <span class="n">vect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">center</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="o">*</span><span class="n">vect</span></div></div>
</pre></div>

          </div>
        </div>
          </div>
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../static/scipyshiny_small.png" alt="Logo">
            </a></p>

        </div>
      </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2019, Flicien Cantalloube.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.7.4.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>
